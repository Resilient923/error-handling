{"ast":null,"code":"import axios, { AxiosError } from \"axios\";\nconst baseUrl = \"https://mock.codes\";\nexport const getApi1 = async () => {\n  return await axios.get(`${baseUrl}/400`);\n};\nexport const getApi2 = async () => {\n  /**\n   * Expected\n   * - 서버가 200을 반환했다면 : return { resp.data: MockCodeResponse }\n   * - 서버가 400을 반환했다면 : throw { throw new Error(status:400) }\n   * - 서버가 죽었다면 : throw { throw new Error(status:500) }\n   * 실제\n   * - 서버가 200을 반환했다면 : 정상\n   * - 서버가 400을 반환했다면 : AxiosError is thrown.\n   * - 서버가 죽었다면 : AxiosError is thrown.\n   */\n  console.log(\"getApi2 called\");\n  const resp = await axios.get(`${baseUrl}asdf/400`); // MockCodeResponse\n\n  if (resp.status !== 200) {\n    console.log(`getApi2 status error : ${resp.status}`);\n    throw new Error();\n  }\n\n  console.log(`success, returning ${resp.data}`);\n  return resp.data;\n};\n\nclass BadRequestError extends Error {\n  constructor(msg) {\n    super(msg); // Set the prototype explicitly.\n\n    Object.setPrototypeOf(this, BadRequestError.prototype);\n  }\n\n}\n\nconst handleAndThrowError = e => {\n  var _e$response;\n\n  if (e instanceof AxiosError && ((_e$response = e.response) === null || _e$response === void 0 ? void 0 : _e$response.status) === 400) {\n    var _e$response2;\n\n    throw new BadRequestError((_e$response2 = e.response) === null || _e$response2 === void 0 ? void 0 : _e$response2.data.description);\n  } else {\n    throw e;\n  }\n};\n\nexport const getApi3 = async () => {\n  // try-catch\n\n  /**\n   * Expected\n   * - 서버가 200을 반환했다면 : return { resp.data: MockCodeResponse }\n   * - 서버가 400을 반환했다면 : (서버가 의미있는 에러메세지를 줬을 것이므로) throw { new BadRequest(message:xx) }\n   * - 서버가 죽었다면 : throw { given AxiosError }\n   * 함의\n   * - 이 함수를 쓰는 너는, (1) 200과 400은 로직을 구현해서 핸들링하고 (2) 500이나 기타에러는 거의 발생안할테니(혹은 발생했다면 에러트래킹을할테니) 신경쓰지마\n   * 실제\n   * - 서버가 200을 반환했다면 : 정상\n   * - 서버가 400을 반환했다면 : 정상\n   * - 서버가 죽었다면 : 정상\n   * 평가\n   * - 장점\n   *   - 스탠다드다. 개발자에게 올바른 방법이다. (=학교에서 배운 방법이다.)\n   * - 단점\n   *   - BadRequestError 를 throw하네요. (디자인에서부터 애초에) try catch 를 강요한 거에요.\n   *   - typescript는 \"there's only one catch\"이기 때문에, catch를 하는 코드를 쓰기가 지저분해요.\n   */\n  console.log(\"getApi3 called\");\n\n  try {\n    const resp = await axios.get(`${baseUrl}/500`);\n    console.log(\"got resp:\");\n    console.log(resp);\n    return resp.data;\n  } catch (e) {\n    // ^ = axios에 의한 오류를 캐치하기 위한 try-catch에요.\n    // . = \"e를 보고, (1) e가 bad request를 뜻하면 BadRequestError를 쏘고, (2) 아니면 e를 쏘고\"\n    // if (e instanceof AxiosError && e.response?.status === 400) {\n    //   throw new BadRequestError(e.response?.data.description);\n    // } else {\n    //   throw e;\n    // }\n    // (x)\n    // return await handleAndThrowError(e);    // return하지 않아요\n    // (x)\n    // handleError(e);    // 얘가 Throw를 하는지 불분명해요\n    // (o)\n    handleAndThrowError(e);\n  }\n};\nexport const myClient = axios.create({\n  baseURL: \"https://mock.codes\",\n  validateStatus: code => {\n    console.log(\"validateStatus called\");\n    if (200 <= code && code < 300) return true;\n    if (code == 400) return true;\n    return false;\n  }\n});\n/**\n * type ApiResponse<T> {\n *   success: boolean,\n *   data?: T,\n *   errorMessage?: str,\n * }\n */\n\nexport const getApi4 = async () => {\n  // x : {param => ApiResponse<MockCodeResponse> } () => {}\n  // modify axios\n\n  /**\n   * Expected\n   * - 서버가 200을 반환했다면 : return { success: true, data: \"resp.data: MockCodeResponse\", errorMessage: null }\n   * - 서버가 400을 반환했다면 : return { success: false, data: null, errorMessage: str }\n   * - 서버가 죽었다면 : throw { given AxiosError }\n   * 실제\n   * - 서버가 200을 반환했다면 :\n   * - 서버가 400을 반환했다면 :\n   * - 서버가 죽었다면 :\n   * 평가\n   * -\n   */\n  console.log(\"getApi4 called\");\n  const resp = await myClient.get(`${baseUrl}asdf/500`); // 이게 400이더라도 throw를 안함.\n  // // bad version\n  // if (resp.status !== 200) {\n  //   console.log(`getApi2 status error : ${resp.status}`);\n  //   if (resp.status == 400) {   // if문 안에 if문이 들어가 있어서,\n  //     return { success: false, description: resp.data.message };\n  //   }\n  // }\n  // // != 400 일 때 도달하는 곳\n  // console.log(`success, returning ${resp.data}`);\n  // return resp.data;\n  // better version\n\n  if (resp.status == 400) {\n    var _resp$data;\n\n    // if문 안에 if문이 들어가 있어서,\n    return {\n      success: false,\n      description: (resp === null || resp === void 0 ? void 0 : (_resp$data = resp.data) === null || _resp$data === void 0 ? void 0 : _resp$data.message) || \"some message\"\n    };\n  } else if (resp.status !== 200) {\n    // cannot happen... but anyway...\n    console.log(`getApi4 status error : ${resp.status}`);\n  }\n\n  console.log(`success, returning ${resp.data}`); // return resp.data;  // 문제가 있어요. 심각해요. caller는 내 요청이 성공했는지 실패했는지 어떻게 알죠?\n\n  return {\n    success: true,\n    data: resp.data\n  };\n}; // 차원이 2개인데\n// (1) 구현시 try를 쓰냐 마냐 (안쓰려면 axios.create 가 필요함)\n// (2) 리턴시 wrapping을 하냐 마나\n// (3)\n\nexport const getApi5 = async () => {\n  /**\n   * Expected\n   * - 서버가 200을 반환했다면 : return { success: true, data: MockCodeResponse }\n   * - 서버가 400을 반환했다면 : return { success: false, message: ~ }\n   * - 서버가 죽었다면 : return { success: false, mesage: ~ }\n   * 실제\n   * 평가\n   * - 장점\n   *   - 갖다 쓰는 사람 입장에서, 엄청 편하다.\n   * - 단점\n   *   - wrapping이 되어있다. 근데 이게 단점인가?\n   *   - 개발철학은 한두개 무시했을지 몰라도, 코드가독성 측면에서는 넘사벽으로 좋다.\n   */\n  console.log(\"getApi5 called\");\n\n  try {\n    const resp = await axios.get(`${baseUrl}asdf/500`); // MockCodeResponse\n\n    return {\n      success: true,\n      data: resp.data\n    };\n  } catch (e) {\n    var _e$response3, _e$response3$data;\n\n    console.log(\"error occured\");\n    console.log(e);\n    const message = ((_e$response3 = e.response) === null || _e$response3 === void 0 ? void 0 : (_e$response3$data = _e$response3.data) === null || _e$response3$data === void 0 ? void 0 : _e$response3$data.description) || `Unknown: ${e.message}` || \"Unknown error\";\n    return {\n      success: false,\n      message: message\n    };\n  }\n};","map":{"version":3,"names":["axios","AxiosError","baseUrl","getApi1","get","getApi2","console","log","resp","status","Error","data","BadRequestError","constructor","msg","Object","setPrototypeOf","prototype","handleAndThrowError","e","response","description","getApi3","myClient","create","baseURL","validateStatus","code","getApi4","success","message","getApi5"],"sources":["/Users/steadyshin/Documents/GitHub/axios-test/axios-test/src/api.ts"],"sourcesContent":["import axios, { AxiosError } from \"axios\";\n\nconst baseUrl = \"https://mock.codes\";\n\nexport const getApi1 = async () => {\n  return await axios.get(`${baseUrl}/400`);\n};\n\nexport const getApi2 = async () => {\n  /**\n   * Expected\n   * - 서버가 200을 반환했다면 : return { resp.data: MockCodeResponse }\n   * - 서버가 400을 반환했다면 : throw { throw new Error(status:400) }\n   * - 서버가 죽었다면 : throw { throw new Error(status:500) }\n   * 실제\n   * - 서버가 200을 반환했다면 : 정상\n   * - 서버가 400을 반환했다면 : AxiosError is thrown.\n   * - 서버가 죽었다면 : AxiosError is thrown.\n   */\n  console.log(\"getApi2 called\");\n  const resp = await axios.get(`${baseUrl}asdf/400`); // MockCodeResponse\n  if (resp.status !== 200) {\n    console.log(`getApi2 status error : ${resp.status}`);\n    throw new Error();\n  }\n  console.log(`success, returning ${resp.data}`);\n  return resp.data;\n};\n\nclass BadRequestError extends Error {\n  constructor(msg: string) {\n    super(msg);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, BadRequestError.prototype);\n  }\n}\n\nconst handleAndThrowError = (e: any) => {\n  if (e instanceof AxiosError && e.response?.status === 400) {\n    throw new BadRequestError(e.response?.data.description);\n  } else {\n    throw e;\n  }\n};\n\nexport const getApi3 = async () => {\n  // try-catch\n  /**\n   * Expected\n   * - 서버가 200을 반환했다면 : return { resp.data: MockCodeResponse }\n   * - 서버가 400을 반환했다면 : (서버가 의미있는 에러메세지를 줬을 것이므로) throw { new BadRequest(message:xx) }\n   * - 서버가 죽었다면 : throw { given AxiosError }\n   * 함의\n   * - 이 함수를 쓰는 너는, (1) 200과 400은 로직을 구현해서 핸들링하고 (2) 500이나 기타에러는 거의 발생안할테니(혹은 발생했다면 에러트래킹을할테니) 신경쓰지마\n   * 실제\n   * - 서버가 200을 반환했다면 : 정상\n   * - 서버가 400을 반환했다면 : 정상\n   * - 서버가 죽었다면 : 정상\n   * 평가\n   * - 장점\n   *   - 스탠다드다. 개발자에게 올바른 방법이다. (=학교에서 배운 방법이다.)\n   * - 단점\n   *   - BadRequestError 를 throw하네요. (디자인에서부터 애초에) try catch 를 강요한 거에요.\n   *   - typescript는 \"there's only one catch\"이기 때문에, catch를 하는 코드를 쓰기가 지저분해요.\n   */\n  console.log(\"getApi3 called\");\n  try {\n    const resp = await axios.get(`${baseUrl}/500`);\n    console.log(\"got resp:\");\n    console.log(resp);\n    return resp.data;\n  } catch (e: any) {\n    // ^ = axios에 의한 오류를 캐치하기 위한 try-catch에요.\n\n    // . = \"e를 보고, (1) e가 bad request를 뜻하면 BadRequestError를 쏘고, (2) 아니면 e를 쏘고\"\n    // if (e instanceof AxiosError && e.response?.status === 400) {\n    //   throw new BadRequestError(e.response?.data.description);\n    // } else {\n    //   throw e;\n    // }\n\n    // (x)\n    // return await handleAndThrowError(e);    // return하지 않아요\n    // (x)\n    // handleError(e);    // 얘가 Throw를 하는지 불분명해요\n    // (o)\n    handleAndThrowError(e);\n  }\n};\n\nexport const myClient = axios.create({\n  baseURL: \"https://mock.codes\",\n  validateStatus: (code) => {\n    console.log(\"validateStatus called\");\n    if (200 <= code && code < 300) return true;\n    if (code == 400) return true;\n    return false;\n  },\n});\n\n/**\n * type ApiResponse<T> {\n *   success: boolean,\n *   data?: T,\n *   errorMessage?: str,\n * }\n */\n\nexport const getApi4 = async () => {\n  // x : {param => ApiResponse<MockCodeResponse> } () => {}\n  // modify axios\n  /**\n   * Expected\n   * - 서버가 200을 반환했다면 : return { success: true, data: \"resp.data: MockCodeResponse\", errorMessage: null }\n   * - 서버가 400을 반환했다면 : return { success: false, data: null, errorMessage: str }\n   * - 서버가 죽었다면 : throw { given AxiosError }\n   * 실제\n   * - 서버가 200을 반환했다면 :\n   * - 서버가 400을 반환했다면 :\n   * - 서버가 죽었다면 :\n   * 평가\n   * -\n   */\n  console.log(\"getApi4 called\");\n  const resp = await myClient.get(`${baseUrl}asdf/500`); // 이게 400이더라도 throw를 안함.\n\n  // // bad version\n  // if (resp.status !== 200) {\n  //   console.log(`getApi2 status error : ${resp.status}`);\n  //   if (resp.status == 400) {   // if문 안에 if문이 들어가 있어서,\n  //     return { success: false, description: resp.data.message };\n  //   }\n  // }\n  // // != 400 일 때 도달하는 곳\n  // console.log(`success, returning ${resp.data}`);\n  // return resp.data;\n\n  // better version\n  if (resp.status == 400) {\n    // if문 안에 if문이 들어가 있어서,\n    return {\n      success: false,\n      description: resp?.data?.message || \"some message\",\n    };\n  } else if (resp.status !== 200) {\n    // cannot happen... but anyway...\n    console.log(`getApi4 status error : ${resp.status}`);\n  }\n  console.log(`success, returning ${resp.data}`);\n  // return resp.data;  // 문제가 있어요. 심각해요. caller는 내 요청이 성공했는지 실패했는지 어떻게 알죠?\n  return { success: true, data: resp.data };\n};\n\n// 차원이 2개인데\n// (1) 구현시 try를 쓰냐 마냐 (안쓰려면 axios.create 가 필요함)\n// (2) 리턴시 wrapping을 하냐 마나\n// (3)\n\nexport const getApi5 = async () => {\n  /**\n   * Expected\n   * - 서버가 200을 반환했다면 : return { success: true, data: MockCodeResponse }\n   * - 서버가 400을 반환했다면 : return { success: false, message: ~ }\n   * - 서버가 죽었다면 : return { success: false, mesage: ~ }\n   * 실제\n   * 평가\n   * - 장점\n   *   - 갖다 쓰는 사람 입장에서, 엄청 편하다.\n   * - 단점\n   *   - wrapping이 되어있다. 근데 이게 단점인가?\n   *   - 개발철학은 한두개 무시했을지 몰라도, 코드가독성 측면에서는 넘사벽으로 좋다.\n   */\n  console.log(\"getApi5 called\");\n  try {\n    const resp = await axios.get(`${baseUrl}asdf/500`); // MockCodeResponse\n    return { success: true, data: resp.data };\n  } catch (e: any) {\n    console.log(\"error occured\");\n    console.log(e);\n    const message =\n      e.response?.data?.description ||\n      `Unknown: ${e.message}` ||\n      \"Unknown error\";\n    return { success: false, message: message };\n  }\n};\n"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,UAAhB,QAAkC,OAAlC;AAEA,MAAMC,OAAO,GAAG,oBAAhB;AAEA,OAAO,MAAMC,OAAO,GAAG,YAAY;EACjC,OAAO,MAAMH,KAAK,CAACI,GAAN,CAAW,GAAEF,OAAQ,MAArB,CAAb;AACD,CAFM;AAIP,OAAO,MAAMG,OAAO,GAAG,YAAY;EACjC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,OAAO,CAACC,GAAR,CAAY,gBAAZ;EACA,MAAMC,IAAI,GAAG,MAAMR,KAAK,CAACI,GAAN,CAAW,GAAEF,OAAQ,UAArB,CAAnB,CAZiC,CAYmB;;EACpD,IAAIM,IAAI,CAACC,MAAL,KAAgB,GAApB,EAAyB;IACvBH,OAAO,CAACC,GAAR,CAAa,0BAAyBC,IAAI,CAACC,MAAO,EAAlD;IACA,MAAM,IAAIC,KAAJ,EAAN;EACD;;EACDJ,OAAO,CAACC,GAAR,CAAa,sBAAqBC,IAAI,CAACG,IAAK,EAA5C;EACA,OAAOH,IAAI,CAACG,IAAZ;AACD,CAnBM;;AAqBP,MAAMC,eAAN,SAA8BF,KAA9B,CAAoC;EAClCG,WAAW,CAACC,GAAD,EAAc;IACvB,MAAMA,GAAN,EADuB,CAGvB;;IACAC,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4BJ,eAAe,CAACK,SAA5C;EACD;;AANiC;;AASpC,MAAMC,mBAAmB,GAAIC,CAAD,IAAY;EAAA;;EACtC,IAAIA,CAAC,YAAYlB,UAAb,IAA2B,gBAAAkB,CAAC,CAACC,QAAF,4DAAYX,MAAZ,MAAuB,GAAtD,EAA2D;IAAA;;IACzD,MAAM,IAAIG,eAAJ,iBAAoBO,CAAC,CAACC,QAAtB,iDAAoB,aAAYT,IAAZ,CAAiBU,WAArC,CAAN;EACD,CAFD,MAEO;IACL,MAAMF,CAAN;EACD;AACF,CAND;;AAQA,OAAO,MAAMG,OAAO,GAAG,YAAY;EACjC;;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEhB,OAAO,CAACC,GAAR,CAAY,gBAAZ;;EACA,IAAI;IACF,MAAMC,IAAI,GAAG,MAAMR,KAAK,CAACI,GAAN,CAAW,GAAEF,OAAQ,MAArB,CAAnB;IACAI,OAAO,CAACC,GAAR,CAAY,WAAZ;IACAD,OAAO,CAACC,GAAR,CAAYC,IAAZ;IACA,OAAOA,IAAI,CAACG,IAAZ;EACD,CALD,CAKE,OAAOQ,CAAP,EAAe;IACf;IAEA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACAD,mBAAmB,CAACC,CAAD,CAAnB;EACD;AACF,CA3CM;AA6CP,OAAO,MAAMI,QAAQ,GAAGvB,KAAK,CAACwB,MAAN,CAAa;EACnCC,OAAO,EAAE,oBAD0B;EAEnCC,cAAc,EAAGC,IAAD,IAAU;IACxBrB,OAAO,CAACC,GAAR,CAAY,uBAAZ;IACA,IAAI,OAAOoB,IAAP,IAAeA,IAAI,GAAG,GAA1B,EAA+B,OAAO,IAAP;IAC/B,IAAIA,IAAI,IAAI,GAAZ,EAAiB,OAAO,IAAP;IACjB,OAAO,KAAP;EACD;AAPkC,CAAb,CAAjB;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,OAAO,GAAG,YAAY;EACjC;EACA;;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEtB,OAAO,CAACC,GAAR,CAAY,gBAAZ;EACA,MAAMC,IAAI,GAAG,MAAMe,QAAQ,CAACnB,GAAT,CAAc,GAAEF,OAAQ,UAAxB,CAAnB,CAhBiC,CAgBsB;EAEvD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;;EACA,IAAIM,IAAI,CAACC,MAAL,IAAe,GAAnB,EAAwB;IAAA;;IACtB;IACA,OAAO;MACLoB,OAAO,EAAE,KADJ;MAELR,WAAW,EAAE,CAAAb,IAAI,SAAJ,IAAAA,IAAI,WAAJ,0BAAAA,IAAI,CAAEG,IAAN,0DAAYmB,OAAZ,KAAuB;IAF/B,CAAP;EAID,CAND,MAMO,IAAItB,IAAI,CAACC,MAAL,KAAgB,GAApB,EAAyB;IAC9B;IACAH,OAAO,CAACC,GAAR,CAAa,0BAAyBC,IAAI,CAACC,MAAO,EAAlD;EACD;;EACDH,OAAO,CAACC,GAAR,CAAa,sBAAqBC,IAAI,CAACG,IAAK,EAA5C,EAxCiC,CAyCjC;;EACA,OAAO;IAAEkB,OAAO,EAAE,IAAX;IAAiBlB,IAAI,EAAEH,IAAI,CAACG;EAA5B,CAAP;AACD,CA3CM,C,CA6CP;AACA;AACA;AACA;;AAEA,OAAO,MAAMoB,OAAO,GAAG,YAAY;EACjC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEzB,OAAO,CAACC,GAAR,CAAY,gBAAZ;;EACA,IAAI;IACF,MAAMC,IAAI,GAAG,MAAMR,KAAK,CAACI,GAAN,CAAW,GAAEF,OAAQ,UAArB,CAAnB,CADE,CACkD;;IACpD,OAAO;MAAE2B,OAAO,EAAE,IAAX;MAAiBlB,IAAI,EAAEH,IAAI,CAACG;IAA5B,CAAP;EACD,CAHD,CAGE,OAAOQ,CAAP,EAAe;IAAA;;IACfb,OAAO,CAACC,GAAR,CAAY,eAAZ;IACAD,OAAO,CAACC,GAAR,CAAYY,CAAZ;IACA,MAAMW,OAAO,GACX,iBAAAX,CAAC,CAACC,QAAF,mFAAYT,IAAZ,wEAAkBU,WAAlB,KACC,YAAWF,CAAC,CAACW,OAAQ,EADtB,IAEA,eAHF;IAIA,OAAO;MAAED,OAAO,EAAE,KAAX;MAAkBC,OAAO,EAAEA;IAA3B,CAAP;EACD;AACF,CA3BM"},"metadata":{},"sourceType":"module"}